---
layout: post
title: "十大排序算法浅涉？"
subtitle: "大一上在万姐姐课上做过的报告👍"
author: "yuruj"
catelog: true
header-style: text
tags:
  - 算法
  - tips
---

# 排序算法浅涉

排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。

![](/img/typora-user-images/截屏2020-09-17 上午10.56.09.png)

稳定的排序？
啥是稳定？？？

稳定性的大致定义：排序前后两个相等的数相对位置不变，则算法稳定。

稳定性的好处：从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。

时间复杂度

时间频度：一个算法中基本语句执行次数称为语句频度或时间频度。记为T(n)。基本语句的执行次数，通常是最内层循环的循环体。

在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。

![](/img/typora-user-images/截屏2020-09-17 上午10.56.29.png)

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。

原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。

## 一、冒泡排序

1、比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2、对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 
3、针对所有的元素重复以上的步骤，除了最后一个。 
4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

![](/img/typora-user-images/截屏2020-09-17 上午10.56.48.png)

![](/img/typora-user-images/截屏2020-09-17 上午10.57.14.png)

## 二、选择排序

首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

![](/img/typora-user-images/截屏2020-09-17 上午10.57.48.png)

## 三、快速排序

快速排序，又称划分交换排序，简称快排，一种排序算法，最早由东尼·霍尔提出。

快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列。

步骤为：

1、挑选基准值：从数列中挑出一个元素，称为“基准”，
2、分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，
3、递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。

递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。

选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。

对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。

最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列。

![](/img/typora-user-images/截屏2020-09-17 上午10.59.00.png)

![](/img/typora-user-images/截屏2020-09-17 上午10.59.18.png)

它分割了标示为"左边（left）"和"右边（right）"的序列部分，借由移动小于a[pivotIndex]的所有元素到子序列的开头，留下所有大于或等于的元素接在他们后面。在这个过程它也为基准元素找寻最后摆放的位置，也就是它回传的值。它暂时地把基准元素移到子序列的结尾，而不会被前述方式影响到。

![](/img/typora-user-images/截屏2020-09-17 上午10.59.45.png)

![](/img/typora-user-images/截屏2020-09-17 上午10.59.59.png)

## 四、插入排序

1、从第一个元素开始，该元素可以认为已经被排序
2、取出下一个元素，在已经排序的元素序列中从后向前扫描
3、如果该元素（已排序）大于新元素，将该元素移到下一位置
4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5、将新元素插入到该位置后
6、重复步骤2~5

可以采用二分查找法来减少比较操作的数目。

![](/img/typora-user-images/截屏2020-09-17 上午11.00.39.png)

如果序列本来是排好序的，那么会触发最好情况。这时只需要n-1次比较即可，没有任何元素移动。所以最好情况下时间复杂度是 O(n)。
如果序列是逆序排列的，那么会触发最坏情况。这时每个元素都需要一步一步地挪到序列首部。所以最坏情况下的时间复杂度是 O(n^2)。
平均情况下的时间复杂度是 O(n^2)

## 五、希尔排序

希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

原始的算法实现在最坏的情况下需要进行O(n^2)的比较和交换。 可以使得性能提升至O(n （log n）^2)。这比最好的比较算法的O(n log n)要差一些。

比较排序有很多性能上的根本限制。在最差情况下，任何一种比较排序至少需要O(n log n）比较操作。这是比较操作所获的信息有限所导致的，或者说是全序集的模糊代数结构所导致的。

![](/img/typora-user-images/截屏2020-09-17 上午11.01.58.png)

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）

步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。

![](/img/typora-user-images/截屏2020-09-17 上午11.02.35.png)

![](/img/typora-user-images/截屏2020-09-17 上午11.02.48.png)

## 六、归并排序

归并操作的工作原理如下：
第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置
第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾

将两个已排好序的数组合并成一个有序的数组,称之为归并排序

![](/img/typora-user-images/截屏2020-09-17 上午11.03.30.png)

![](/img/typora-user-images/截屏2020-09-17 上午11.03.47.png)

![](/img/typora-user-images/截屏2020-09-17 上午11.03.59.png)

## 六、基数排序

是一种非比较型整数排序算法
基数排序属于“分配式排序”，又称“桶子法”

LSD MSD

LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好

## 八、堆排序

堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。

从下往上，从左往右

若以升序排序说明，把数组转换成最大堆积(Max-Heap Heap)，这是一种满足最大堆积性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。

重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。

堆排序的效率与快排、归并相同，都达到了基于比较的排序算法效率的峰值（时间复杂度为O(nlogn)）
除了高效之外，最大的亮点就是只需要O(1)的辅助空间了，既最高效率又最节省空间
堆排序效率相对稳定，不像快排在最坏情况下时间复杂度会变成O(n^2)），所以无论待排序序列是否有序，堆排序的效率都是O(nlogn)不变（注意这里的稳定特指平均时间复杂度=最坏时间复杂度，不是那个“稳定”，因为堆排序本身是不稳定的）

## 九、桶排序

## 十、计数排序

