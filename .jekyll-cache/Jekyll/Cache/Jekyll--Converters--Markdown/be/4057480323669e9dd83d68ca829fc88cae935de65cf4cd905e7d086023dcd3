I"{G<h1 id="threading-programming-guide1">Threading Programming Guide（1）</h1>

<h2 id="介绍">介绍</h2>

<p>线程是使在单个应用程序内同时执行多个代码路径成为可能的几种技术之一。尽管诸如操作对象和Grand Central Dispatch（GCD）等较新的技术为实现并发提供了更现代，更高效的基础架构，但是OS X和iOS还提供了用于创建和管理线程的接口。</p>

<h2 id="关于线程编程">关于线程编程</h2>

<p>多年来，最大的计算机性能在很大程度上受到位于计算机中心的单个微处理器速度的限制。但是，随着单个处理器的速度开始达到其实际极限，芯片制造商转向了多核设计，从而使计算机有机会同时执行多项任务。而且，尽管OS X只要能够执行与系统有关的任务就可以利用这些内核，但是您自己的应用程序也可以通过线程利用它们。</p>

<h3 id="什么是线程">什么是线程？</h3>

<p>线程是在应用程序内部实现多个执行路径的相对轻量的方法。在系统级别，程序并排运行，系统根据每个程序的需求和其他程序的需求分配执行时间。但是，每个程序中都存在一个或多个执行线程，这些线程可用于同时或以几乎同时的方式执行不同的任务。系统本身实际上管理着这些执行线程，调度它们在可用内核上运行，并根据需要抢先中断它们以允许其他线程运行。</p>

<p>从技术角度来看，线程是管理代码执行所需的内核级和应用程序级数据结构的组合。内核级结构在一个可用内核上协调事件向线程的调度和线程的抢占式调度。应用程序级结构包括用于存储函数调用的调用堆栈，以及应用程序管理和操纵线程的属性和状态所需的结构。</p>

<p>在非并行应用程序中，只有一个执行线程。该线程以应用程序的<code class="language-plaintext highlighter-rouge">main</code>例程开始和结束，并且一个一个地分支到不同的方法或函数，以实现应用程序的整体行为。相比之下，支持并发的应用程序从一个线程开始，并根据需要添加更多线程以创建其他执行路径。每个新路径都有其自己的自定义启动例程，该例程独立于应用程序<code class="language-plaintext highlighter-rouge">main</code>例程中的代码运行。应用程序中具有多个线程可提供两个非常重要的潜在优势：</p>

<ul>
  <li>多个线程可以提高应用程序的感知响应能力。</li>
  <li>多线程可以提高应用程序在多核系统上的实时性能。</li>
</ul>

<p>如果您的应用程序只有一个线程，则该线程必须执行所有操作。它必须响应事件，更新应用程序的窗口并执行实现应用程序行为所需的所有计算。仅具有一个线程的问题在于，它一次只能执行一件事。那么，当您的计算之一需要很长时间才能完成时，会发生什么？当您的代码忙于计算所需的值时，您的应用程序将停止响应用户事件并更新其窗口。如果此行为持续足够长的时间，则用户可能会认为您的应用程序已挂起，并试图强行退出它。但是，如果将自定义计算移动到单独的线程上，则应用程序的主线程将可以自由地更及时地响应用户交互。</p>

<p>对于当今常见的多核计算机，线程提供了一种提高某些类型的应用程序性能的方法。执行不同任务的线程可以在不同处理器核心上同时执行操作，从而使应用程序可以在给定的时间内增加其工作量。</p>

<p>当然，线程不是解决应用程序性能问题的灵丹妙药。除了线程提供的好处外，还有潜在的问题。在应用程序中具有多个执行路径会给您的代码增加相当多的复杂性。每个线程必须与其他线程协调其操作，以防止其破坏应用程序的状态信息。由于单个应用程序中的线程共享相同的内存空间，因此它们可以访问所有相同的数据结构。如果两个线程试图同时操作相同的数据结构，则一个线程可能会以破坏结果数据结构的方式覆盖另一个线程的更改。即使有适当的保护措施，您仍然必须提防编译器优化，这些优化会在代码中引入细微（而不是细微）的错误。</p>

<h3 id="线程术语">线程术语</h3>

<p>线程：用于指代代码的独立执行路径</p>

<p>进程：用于指代一个正在运行的可执行文件，它可以包含多个线程</p>

<p>任务：用于指代需要执行的工作的抽象概念</p>

<h3 id="线程替代">线程替代</h3>

<p>自己创建线程的一个问题是它们增加了代码的不确定性。线程是在应用程序中支持并发的相对较低级别和复杂方式。如果您不完全了解设计选择的含义，则很容易会遇到同步或时序问题，其严重性可能从细微的行为更改到应用程序崩溃和用户数据损坏。</p>

<p>要考虑的另一个因素是根本是否需要线程或并发。线程解决了如何在同一进程内同时执行多个代码路径的特定问题。但是，在某些情况下，您所做的工作量不能保证并发。线程在内存消耗和CPU时间方面都会给您的进程带来大量开销。您可能会发现此开销对于预期的任务而言太大，或者其他选项更易于实现。</p>

<p><img src="/img/typora-user-images/截屏2020-09-10 下午12.02.04.png" alt="" /></p>

<h3 id="线程支持">线程支持</h3>

<p>如果您已有使用线程的代码，则OS X和iOS提供了几种在应用程序中创建线程的技术。此外，两个系统还提供了对管理和同步在这些线程上需要完成的工作的支持。</p>

<h4 id="线程包">线程包</h4>

<p>尽管线程的底层实现机制是Mach线程，但你很少(如果有的话)在Mach级别上使用线程。相反，您通常使用更方便的POSIX API或它的一个衍生物。Mach实现提供了所有线程的基本特性，但是，包括优先执行模型和调度线程的能力，使它们彼此独立。</p>

<p><img src="/img/typora-user-images/截屏2020-09-10 下午12.11.56.png" alt="" /></p>

<p>在应用程序级别，所有线程的行为基本上与其他平台上的行为相同。启动线程后，线程以三种主要状态之一运行：运行，就绪或阻塞。如果线程当前未在运行，则要么阻塞并等待输入，要么准备运行，但尚未安排这样做。线程继续在这些状态之间来回移动，直到最终退出并移动到终止状态。</p>

<p>创建新线程时，必须为该线程指定入口点函数（对于Cocoa线程，则为入口点方法）。该入口点函数构成您要在线程上运行的代码。当函数返回时，或显式终止线程时，线程将永久停止并被系统回收。由于就内存和时间而言，创建线程的成本相对较高，因此建议您的入口点函数执行大量工作或设置运行循环以允许执行重复工作。</p>

<h4 id="run-loops">Run Loops</h4>

<p>运行循环是用于管理异步到达线程的事件的基础架构。运行循环通过监视线程的一个或多个事件源来工作。当事件到达时，系统将唤醒线程并将事件分配给运行循环，然后运行循环将其分配给您指定的处理程序。如果不存在任何事件并准备处理事件，则运行循环会将线程置于睡眠状态。</p>

<p>您不需要对创建的任何线程使用运行循环，但是这样做可以为用户提供更好的体验。运行循环可以创建使用最少资源的长寿命线程。由于运行循环在无事可做时将其线程置于睡眠状态，因此消除了轮询的需要，这浪费了CPU周期，并阻止了处理器本身休眠并节省功耗。</p>

<p>要配置运行循环，您所要做的就是启动线程，获取对运行循环对象的引用，安装事件处理程序，并告诉运行循环运行。OS X提供的基础结构会自动为您处理主线程运行循环的配置。但是，如果计划创建寿命长的辅助线程，则必须自己为这些线程配置运行循环。</p>

<h4 id="同步工具">同步工具</h4>

<p>线程编程的危害之一是多个线程之间的资源争用。如果多个线程尝试同时使用或修改同一资源，则可能会出现问题。缓解此问题的一种方法是完全消除共享资源，并确保每个线程都有其自己独特的资源集来进行操作。但是，当不能完全维护单独的资源时，您可能必须使用锁，条件，原子操作和其他技术来同步对资源的访问。</p>

<p>锁为一次只能由一个线程执行的代码提供了暴力保护形式。锁的最常见类型是互斥锁，也称为<em>互斥锁</em>。当一个线程尝试获取当前由另一个线程持有的互斥锁时，它将阻塞，直到另一个线程释放该锁为止。尽管它们都基于相同的基础技术，但有几个系统框架提供对互斥锁的支持。此外，Cocoa提供了互斥锁的多种变体，以支持不同类型的行为，例如递归。有关可用锁类型的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-126320">锁</a>。</p>

<p>除锁定外，系统还提供条件支持，以确保在应用程序中正确排序任务。条件充当关守，阻塞给定线程，直到它表示的条件变为真为止。发生这种情况时，条件将释放线程并允许其继续。POSIX层和Foundation框架都直接提供条件支持。（如果使用操作对象，则可以配置操作对象之间的依赖关系以对任务的执行进行排序，这与条件提供的行为非常相似。）</p>

<p>尽管锁和条件在并发设计中非常常见，但是原子操作是保护和同步对数据的访问的另一种方法。在可以对标量数据类型执行数学或逻辑运算的情况下，原子运算提供了一种轻巧的替代锁的方法。原子操作使用特殊的硬件指令来确保在其他线程有机会访问变量之前完成对变量的修改。</p>

<h4 id="线程间通讯">线程间通讯</h4>

<p>尽管良好的设计可以最大程度地减少所需的通信量，但在某些时候，线程之间的通信还是很有必要的。（线程的工作是为您的应用程序工作，但是如果从未使用该工作的结果，那有什么用呢？）线程可能需要处理新的工作请求或将其进度报告给应用程序的主线程。在这些情况下，您需要一种从一个线程到另一个线程获取信息的方法。幸运的是，线程共享相同的进程空间这一事实意味着您有很多通信选项。</p>

<p>线程之间有许多通信方式，每种都有其自身的优点和缺点。配置线程本地存储列出了可以在OS X中使用的最常见的通信机制。（除了消息队列和Cocoa分布式对象，这些技术在iOS中也可用。）按递增顺序列出了下表中的技术复杂。</p>

<p><img src="/img/typora-user-images/截屏2020-09-10 下午12.20.56.png" alt="" /></p>

<h3 id="设计技巧">设计技巧</h3>

<h4 id="避免明确创建线程">避免明确创建线程</h4>

<p>手动编写线程创建代码很繁琐，并且可能容易出错，因此应尽可能避免这样做。OS X和iOS通过其他API为并发提供隐式支持。与其自己创建一个线程，不如考虑使用异步API，GCD或操作对象来完成工作。这些技术可以在后台为您完成与线程相关的工作，并且可以保证正确进行。此外，GCD和操作对象等技术旨在根据当前系统负载调整活动线程的数量，从而比您自己的代码更有效地管理线程。</p>

<h4 id="保持线程合理忙碌">保持线程合理忙碌</h4>

<p>如果决定手动创建和管理线程，请记住线程会消耗宝贵的系统资源。您应该尽力确保分配给线程的所有任务都可以长期有效地工作。同时，您不必担心终止花费大部分空闲时间的线程。线程占用的内存非常少，其中一些已连接，因此释放空闲线程不仅有助于减少应用程序的内存占用，还可以释放更多的物理内存供其他系统进程使用。</p>

<h4 id="避免共享数据结构">避免共享数据结构</h4>

<p>当您最小化线程之间的通信和资源争用时，并行代码最有效。</p>

<p>创建多线程应用程序很困难。即使您非常谨慎并在代码的所有适当位置锁定共享数据结构，您的代码在语义上仍可能是不安全的。例如，如果您的代码希望共享数据结构按特定顺序进行修改，则可能会遇到问题。将代码更改为基于事务的模型以进行补偿可能会随后抵消具有多个线程的性能优势。首先，消除资源争用通常会导致设计简单，性能出色。</p>

<h4 id="线程和用户界面">线程和用户界面</h4>

<p>如果您的应用程序具有图形用户界面，建议您接收与用户相关的事件，并从应用程序的主线程启动界面更新。这种方法有助于避免与处理用户事件和绘制窗口内容相关的同步问题。某些框架（例如Cocoa）通常需要此行为，但是即使对于那些不需要的框架，在主线程上保留此行为也具有简化用于管理用户界面的逻辑的优势。</p>

<p>有一些值得注意的例外，从其他线程执行图形操作是有利的。例如，您可以使用辅助线程来创建和处理图像以及执行其他与图像有关的计算。对这些操作使用辅助线程可以大大提高性能。但是，如果不确定某个特定的图形操作，请计划从主线程执行该操作。</p>

<h4 id="注意退出时的线程行为">注意退出时的线程行为</h4>

<p>进程一直运行到所有非分离线程都退出为止。默认情况下，仅将应用程序的主线程创建为非分离主线程，但是您也可以以这种方式创建其他线程。当用户退出应用程序时，通常认为立即终止所有分离的线程是适当的行为，因为分离的线程完成的工作被认为是可选的。但是，如果您的应用程序正在使用后台线程将数据保存到磁盘或执行其他关键工作，则可能需要将这些线程创建为非分离线程，以防止在应用程序退出时丢失数据。</p>

<p>将线程创建为非分离线程（也称为可连接线程）需要您做额外的工作。因为默认情况下大多数高级线程技术都不创建可连接线程，所以您可能必须使用POSIX API创建线程。另外，您必须向应用程序的主线程添加代码，以便在非分离线程最终退出时与它们分离。</p>

<p>如果您正在编写Cocoa应用程序，则还可以使用<code class="language-plaintext highlighter-rouge">applicationShouldTerminate:</code>委托方法将应用程序的终止延迟到以后或完全取消。延迟终止时，您的应用程序将需要等到所有关键线程完成其任务，然后再调用该<code class="language-plaintext highlighter-rouge">replyToApplicationShouldTerminate:</code>方法。</p>

<h4 id="处理异常">处理异常</h4>

<p>引发异常时，异常处理机制依赖于当前的调用堆栈来执行任何必要的清除。因为每个线程都有自己的调用堆栈，所以每个线程负责捕获自己的异常。在辅助线程中未能捕获到异常与在主线程中未能捕获到异常相同：拥有过程终止。您不能将未捕获的异常抛出到另一个线程进行处理。</p>

<p>如果您需要在当前线程中将异常情况通知另一个线程（例如主线程），则应捕获该异常，并仅向该另一个线程发送一条消息，指出发生了什么。根据您的模型和您要执行的操作，捕获到异常的线程可以继续处理（如果可能的话），等待指令或只是退出。</p>

<p><strong>注意：</strong> 在可可中，<code class="language-plaintext highlighter-rouge">NSException</code>对象是一个独立的对象，一旦被捕获，即可在线程之间传递。</p>

<p>在某些情况下，可能会自动为您创建一个异常处理程序。例如，<code class="language-plaintext highlighter-rouge">@synchronized</code>Objective-C中的指令包含一个隐式异常处理程序。</p>

<h4 id="干净的终止线程">干净的终止线程</h4>

<p>退出线程的最佳方法自然是让线程到达其主入口点例程的末尾。尽管有立即终止线程的功能，但这些功能仅应作为最后的手段使用。在线程到达其自然终点之前终止该线程可防止线程在其自身清除之后清理。如果线程已分配内存，打开文件或获取其他类型的资源，则您的代码可能无法回收这些资源，从而导致内存泄漏或其他潜在问题。</p>

<h4 id="库中的线程安全">库中的线程安全</h4>

<p>尽管应用程序开发人员可以控制应用程序是否使用多个线程执行，但是库开发人员却不能。开发库时，必须假定调用应用程序是多线程的，或者可以随时切换为多线程。因此，您应该始终对代码的关键部分使用锁。</p>

<p>对于库开发人员，仅当应用程序变为多线程时才创建锁是不明智的。如果需要在某个时候锁定代码，请在使用库时尽早创建锁定对象，最好是通过某种显式调用来初始化库。尽管您还可以使用静态库初始化函数来创建此类锁，但是仅在没有其他方法时才尝试这样做。执行初始化函数会增加加载库所需的时间，并且可能会对性能产生不利影响。</p>

<p>始终记住平衡调用以锁定和解锁库中的互斥锁。您还应该记住锁定库数据结构，而不是依靠调用代码来提供线程安全的环境。</p>

<p>如果要开发Cocoa库，可以在<code class="language-plaintext highlighter-rouge">NSWillBecomeMultiThreadedNotification</code>想要成为应用程序多线程时收到通知的情况下，注册为的观察者。但是，您不应依赖于接收此通知，因为它可能在调用库代码之前就已分派。</p>
:ET